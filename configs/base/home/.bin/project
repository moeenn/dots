#! /usr/bin/python3

from abc import ABC, abstractmethod
import os
import argparse
import subprocess


class BaseTemplate(ABC):
    """
    abstract class which will be inherited by all template classes.
    """

    project_name: str
    project_dir: str
    files_and_content: dict[str, str]

    def __init__(self, project_name: str) -> None:
        self.project_name = project_name
        self.project_dir = os.path.join(os.getcwd(), project_name)

    def execute(self) -> None:
        self.create_dir(self.project_dir)
        self.__write_gitignore()
        self.__create_project_dirs()

        for file_path, content in self.files_and_content.items():
            self.write_file(os.path.join(self.project_dir, file_path), content)

        # initialize git repo.
        cmd = ["git", "init"]
        subprocess.run(cmd, cwd=self.project_dir)

    def create_dir(self, dir_path: str) -> None:
        if os.path.exists(dir_path):
            raise Exception(f"directory already exists: {dir_path}")
        else:
            os.makedirs(dir_path)

    def write_file(self, file_path: str, content: str) -> None:
        if os.path.exists(file_path):
            raise Exception(f"file already exists: {file_path}")
        else:
            with open(file_path, "w") as f:
                f.write(content)

    @staticmethod
    @abstractmethod
    def template_name() -> str:
        pass

    @abstractmethod
    def gitignore_entries(self) -> list[str]:
        pass

    @abstractmethod
    def project_directories(self) -> list[str]:
        pass

    def __create_project_dirs(self) -> None:
        for dir in self.project_directories():
            self.create_dir(os.path.join(self.project_dir, dir))

    def __write_gitignore(self) -> None:
        entries = self.gitignore_entries()
        content = "\n".join(entries)
        self.write_file(os.path.join(self.project_dir, ".gitignore"), content)


class GoTemplate(BaseTemplate):
    """
    template class for go projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_go_path = os.path.join("cmd", self.project_name, "main.go")
        self.files_and_content = {
            main_go_path: self.main_go_content(),
            "Makefile": self.makefile_content(),
            ".golangci.yml": self.golangci_lint_content(),
        }

    @staticmethod
    def template_name() -> str:
        return "go"

    def gitignore_entries(self) -> list[str]:
        return ["bin"]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("cmd", self.project_name),
        ]

    def execute(self) -> None:
        super().execute()

        # init go module.
        cmd = ["go", "mod", "init", self.project_name]
        subprocess.run(cmd, cwd=self.project_dir)

        # make tools script executable.
        subprocess.run(["chmod", "+x", "scripts/tools.sh"], cwd=self.project_dir)

    def main_go_content(self) -> str:
        return """package main

import (
    "fmt"
    "os"
)

func run() error {
    fmt.Println("hello world")
    return nil
}

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %s\\n", err.Error())
        os.Exit(1)
    }
}
""".strip()

    def golangci_lint_content(self) -> str:
        return """
version: "2"

linters:
  enable:
    - exhaustive
    - exhaustruct
    - gosec
    - nilnil
    - nilerr
    - contextcheck
    - gochecknoinits
    - godox
    - misspell
    - sloglint

  settings:
    sloglint:
      no-mixed-args: true
      static-msg: true
      key-naming-case: camel
      args-on-sep-lines: true
""".strip()

    def makefile_content(self) -> str:
        return f"""
PROJECT = {self.project_name}
MAIN_FILE = ./cmd/$(PROJECT)/main.go

lint:
	golangci-lint run ./...

test:
	go test ./...

run:
	go run $(MAIN_FILE)

build: lint test
	go build -o ./bin/$(PROJECT) $(MAIN_FILE)

.PHONY: lint test run
  """.strip()


class CTemplate(BaseTemplate):
    """
    template class for c projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_c_path = os.path.join("src", "main.c")
        self.files_and_content = {
            main_c_path: self.main_c_content(),
            "Makefile": self.makefile_content(),
        }

    @staticmethod
    def template_name() -> str:
        return "c"

    def gitignore_entries(self) -> list[str]:
        return ["bin/*", ".cache/", "compile_commands.json"]

    def project_directories(self) -> list[str]:
        return ["src", "bin"]

    def main_c_content(self) -> str:
        return """
#include <stdio.h>

#ifdef TEST
#include <assert.h>
#endif

typedef enum {
    RESULT_OK = 0,
    RESULT_ERR = 1,    
} result_e;

#ifdef TEST
void test_example()
{
    printf("[TEST] %s.\\n", __func__);
    assert(1 == 1);    
}
#endif

#ifdef TEST
int main()
{
    test_example();
}
#endif

#ifndef TEST
int main()
{
    printf("hello world\\n");
    return RESULT_OK;
}
#endif
    """.strip()

    def makefile_content(self) -> str:
        return f"""
CC=cc
SRC := ./src/*.c
TARGET={self.project_name}
CFLAGS=-Wall -Wextra -std=c23

main:
	 @${{CC}} ${{SRC}} -o ./bin/${{TARGET}}

test:
	@${{CC}} ${{CFLAGS}} -DTEST ${{SRC}} -o ./bin/${{TARGET}} && ./bin/${{TARGET}}

clean:
	rm -f ./bin/*

.PHONY: clean
""".strip()


class JavaTemplate(BaseTemplate):
    """
    template class for java+maven projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join(
            "src", "main", "java", "com", self.project_name, "Main.java"
        )
        test_path = os.path.join(
            "src", "test", "java", "com", self.project_name, "MainTest.java"
        )
        self.files_and_content = {
            "README.md": self.readme_md_content(),
            main_path: self.main_content(),
            test_path: self.test_content(),
            "pom.xml": self.pom_xml_content(),
        }

    @staticmethod
    def template_name() -> str:
        return "java"

    def gitignore_entries(self) -> list[str]:
        return [".classpath", "target", ".project", ".settings", ".idea"]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("src", "main", "java", "com", self.project_name),
            os.path.join("src", "test", "java", "com", self.project_name),
        ]

    def main_content(self) -> str:
        return f"""
package com.{self.project_name};

public class Main {{
    public static void main(String[] args) {{
        System.out.println("hello world");
    }}
}}           
        """.strip()

    def test_content(self) -> str:
        return f"""
package com.{self.project_name};

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class MainTest {{
  @Test
  public void testAssertion() {{
    assertEquals(1, 1);
  }}
}}        
        """.strip()

    def pom_xml_content(self) -> str:
        return f"""
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.{self.project_name}.Main</groupId>
  <artifactId>{self.project_name}</artifactId>
  <version>1.0</version>

  <build>
    <plugins>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <archive>
            <manifest>
              <mainClass>com.{self.project_name}.Main</mainClass>
            </manifest>
          </archive>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
        </configuration>
      </plugin>
    </plugins>
  </build>

  <properties>
    <java.version>21</java.version>
    <exec.mainClass>com.{self.project_name}.Main</exec.mainClass>
    <maven.compiler.source>${{java.version}}</maven.compiler.source>
    <maven.compiler.target>${{java.version}}</maven.compiler.target>
    <maven.compiler.release>${{java.version}}</maven.compiler.release>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>    
  </properties>

  <dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.3</version>
        <scope>test</scope>
    </dependency>
  </dependencies>
</project>
        """.strip()

    def readme_md_content(self) -> str:
        return f"""
## {self.project_name}

### Commands

```bash
# install dependencies.
$ mvn install

# compile.
$ mvn clean compile assembly:single

# run jar.
$ java -jar ./target/{self.project_name}-1.0-jar-with-dependencies.jar
```
        """.strip()


class TsTemplate(BaseTemplate):
    """
    template class for Javascript projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join("src", "main.ts")
        main_test_path = os.path.join("src", "main.test.ts")

        self.files_and_content = {
            "README.md": self.readme_content(),
            main_path: self.main_content(),
            main_test_path: self.main_test_content(),
            "tsconfig.json": self.tsconfig_content(),
            "package.json": self.package_json_content(),
            "eslint.config.js": self.eslint_config_content(),
        }

    @staticmethod
    def template_name() -> str:
        return "ts"

    def gitignore_entries(self) -> list[str]:
        return ["node_modules/", ".DS_Store", "dist/"]

    def project_directories(self) -> list[str]:
        return ["src"]

    def execute(self) -> None:
        super().execute()

        # install npm dependencies.
        print("installing dependencies...")
        cmd = ["npm", "i"]
        subprocess.run(cmd, cwd=self.project_dir)

    def readme_content(self) -> str:
        return f"""
# {self.project_name}

## Scripts

```bash
# start the application
$ npm start

# run the tests (using native NodeJS test runner)
$ npm test

# perform linting (using Eslint) and type checking (using TSC)
$ npm run check

# format code (using prettier)
$ npm run fmt
```
		""".strip()

    def main_content(self) -> str:
        return """
function main(): void {
    console.log("Hello world")
}

main()
		""".strip()

    def main_test_content(self) -> str:
        return """
import test from "node:test"
import assert from "node:assert/strict"

test("simple test", async () => {
    assert.equal(true, true)
})
		""".strip()

    def tsconfig_content(self) -> str:
        return """
{
	"$schema": "https://json.schemastore.org/tsconfig",
    "display": "Strictest",
	"compilerOptions": {
        "strict": true,
        "allowUnusedLabels": false,
        "allowUnreachableCode": false,
        "exactOptionalPropertyTypes": true,
        "noFallthroughCasesInSwitch": true,
        "noImplicitOverride": true,
        "noImplicitReturns": true,
        "noPropertyAccessFromIndexSignature": true,
        "noUncheckedIndexedAccess": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "isolatedModules": true,
        "checkJs": true,
        "esModuleInterop": true,
		"target": "ESNext",
		"module": "NodeNext",
		"verbatimModuleSyntax": true,
		"skipLibCheck": true,
		"types": ["node"],
		"outDir": "./dist",
		"baseUrl": ".",
		"paths": {
			"#src/*": ["./src/*"]
		}
	},
	"exclude": ["node_modules"]
}        
		""".strip()

    def package_json_content(self) -> str:
        return """
{
    "name": "sandbox",
    "version": "0.0.1",
    "type": "module",
    "main": "main.js",
    "scripts": {
        "start": "tsx ./src/main.ts",
        "fmt": "npx prettier --write ./src/",
        "type-check": "npx tsc --noEmit",
        "lint": "npx eslint --fix ./src/",
        "check": "npm run type-check && npm run lint",
        "build": "npx ncc build --minify --v8-cache --no-source-map-register ./src/main.ts -o ./dist",
        "test": "node --import tsx --test"
    },
    "prettier": {
        "singleQuote": false,
        "semi": false,
        "tabWidth": 4,
        "trailingComma": "all",
        "printWidth": 100
    },
    "imports": {
        "#src/*": "./dist/*"
    },
    "devDependencies": {
        "@types/node": "^24.2.0",
        "@vercel/ncc": "^0.38.3",
        "eslint": "^9.32.0",
        "prettier": "^3.6.2",
        "tsx": "^4.20.3",
        "typescript": "^5.9.2",
        "typescript-eslint": "^8.39.0"
    }
}
	""".strip()

    def eslint_config_content(self) -> str:
        return """
import tseslint from "typescript-eslint"

export default [
    { files: ["**/*.ts"] },
    ...tseslint.configs.recommended,
    {
        rules: {
            "no-console": "warn",
            "no-warning-comments": [
                "warn",
                { terms: ["TODO", "FIXME"], location: "anywhere" },
            ],
            quotes: [
                "warn",
                "double",
                {
                    allowTemplateLiterals: true,
                    avoidEscape: true,
                },
            ],
            semi: ["warn", "never"],
            "no-unused-vars": "warn",
        },
    },
]
	""".strip()


class PythonTemplate(BaseTemplate):
    """
    template class for Python projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        app_path = os.path.join("app", "app.py")
        app_test_path = os.path.join("app", "app_test.py")
        init_app_path = os.path.join("app", "__init__.py")

        self.files_and_content = {
            "README.md": self.readme_content(),
            app_path: self.app_content(),
            app_test_path: self.app_test_content(),
            init_app_path: self.init_app_content(),
            "main.py": self.main_content(),
            "pyproject.toml": self.pyproject_toml_content(),
        }

    @staticmethod
    def template_name() -> str:
        return "py"

    def gitignore_entries(self) -> list[str]:
        return [
            "__pycache__",
            "build",
            ".mypy_cache",
            "*.egg-info",
            ".DS_Store",
            ".vscode",
            ".venv",
        ]

    def project_directories(self) -> list[str]:
        return ["app"]

    def readme_content(self) -> str:
        return f"""
# {self.project_name}

## Commands

```bash
# install run-time dependencies.
$ pip install .

# install dev dependencies.
$ pip install .[dev]

# run project.
$ python -m main
```
""".strip()

    def init_app_content(self) -> str:
        return """
from .app import main
      """.strip()

    def app_content(self) -> str:
        return """
def main() -> None:
    print("hello world")
        """.strip()

    def app_test_content(self) -> str:
        return """
from unittest import TestCase


class TestMain(TestCase):
    def test_main(self) -> None:
        self.assertTrue(True)
      """.strip()

    def main_content(self) -> str:
        return """
from app import main


if __name__ == "__main__":
    try:
        main()
    except Exception as ex:
        print("error: ", ex)
        """.strip()

    def pyproject_toml_content(self) -> str:
        return f"""
[project]
name = "{self.project_name}"
version = "1.0.0"
dependencies = []

[project.optional-dependencies]
dev = []
        """.strip()


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", "--name", help="Project name", required=True)
    parser.add_argument("-t", "--template", help="Project template", required=True)
    args = parser.parse_args()

    registered_templates: list[BaseTemplate] = [
        GoTemplate(args.name),
        CTemplate(args.name),
        JavaTemplate(args.name),
        TsTemplate(args.name),
        PythonTemplate(args.name),
    ]

    found = False
    for template in registered_templates:
        if template.template_name() == args.template:
            found = True
            template.execute()
            break

    if not found:
        raise Exception(f"invalid template name: {args.template}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("ctrl+c: exiting...")
    except Exception as e:
        print("error:", e)
