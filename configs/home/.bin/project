#! /usr/bin/python3

from abc import ABC, abstractmethod
import os
import argparse
import subprocess


class BaseTemplate(ABC):
    """
    abstract class which will be inherited by all template classes.
    """
    project_name: str
    project_dir: str
    files_and_content: dict[str, str]

    def __init__(self, project_name: str) -> None:
        self.project_name = project_name
        self.project_dir = os.path.join(os.getcwd(), project_name)

    def execute(self) -> None:
        self.create_dir(self.project_dir)
        self.__write_gitignore()
        self.__create_project_dirs()

        for file_path, content in self.files_and_content.items():
            self.write_file(os.path.join(self.project_dir, file_path), content)

        # initialize git repo.
        cmd = ["git", "init"]
        subprocess.run(cmd, cwd=self.project_dir)

    def create_dir(self, dir_path: str) -> None:
        if os.path.exists(dir_path):
            raise Exception(f"directory already exists: {dir_path}")
        else:
            os.makedirs(dir_path)

    def write_file(self, file_path: str, content: str) -> None:
        if os.path.exists(file_path):
            raise Exception(f"file already exists: {file_path}")
        else:
            with open(file_path, "w") as f:
                f.write(content)

    @staticmethod
    @abstractmethod
    def template_names() -> list[str]:
        pass

    @abstractmethod
    def gitignore_entries(self) -> list[str]:
        pass

    @abstractmethod
    def project_directories(self) -> list[str]:
        pass

    def __create_project_dirs(self) -> None:
        for dir in self.project_directories():
            self.create_dir(os.path.join(self.project_dir, dir))

    def __write_gitignore(self) -> None:
        entries = self.gitignore_entries()
        content = "\n".join(entries)
        self.write_file(os.path.join(self.project_dir, ".gitignore"), content)


class GoTemplate(BaseTemplate):
    """
    template class for go projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_go_path = os.path.join("cmd", self.project_name, "main.go")
        self.files_and_content = {
            main_go_path: self.main_go_content(),
            "Makefile": self.makefile_content(),
            ".golangci.yml": self.golangci_lint_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["go"]

    def gitignore_entries(self) -> list[str]:
        return ["bin"]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("cmd", self.project_name),
        ]

    def execute(self) -> None:
        super().execute()

        # init go module.
        cmd = ["go", "mod", "init", self.project_name]
        subprocess.run(cmd, cwd=self.project_dir)

    def main_go_content(self) -> str:
        return """package main

import (
    "fmt"
    "os"
)

func run() error {
    fmt.Println("hello world")
    return nil
}

func main() {
    if err := run(); err != nil {
        fmt.Fprintf(os.Stderr, "error: %s\\n", err.Error())
        os.Exit(1)
    }
}
""".strip()

    def golangci_lint_content(self) -> str:
        return """
version: "2"

linters:
  enable:
    - exhaustive
    - exhaustruct
    - gosec
    - nilnil
    - nilerr
    - contextcheck
    - gochecknoinits
    - godox
    - misspell
    - sloglint

  settings:
    sloglint:
      no-mixed-args: true
      static-msg: true
      key-naming-case: camel
      args-on-sep-lines: true
""".strip()

    def makefile_content(self) -> str:
        return f"""
PROJECT = {self.project_name}
MAIN_FILE = ./cmd/$(PROJECT)/main.go

lint:
	golangci-lint run ./...

test:
	go test ./...

run:
	go run $(MAIN_FILE)

build: lint test
	go build -o ./bin/$(PROJECT) $(MAIN_FILE)

.PHONY: lint test run
  """.strip()


class CTemplate(BaseTemplate):
    """
    template class for c projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)
        main_c_path = os.path.join("src", "main.c")
        common_h_path = os.path.join("include", "common.h")
        self.files_and_content = {
            main_c_path: self.main_c_content(),
            common_h_path: self.common_h_content(),
            "Makefile": self.makefile_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["c"]

    def gitignore_entries(self) -> list[str]:
        return ["bin/*", ".cache/", "compile_commands.json"]

    def project_directories(self) -> list[str]:
        return ["src", "bin", "include"]

    def execute(self) -> None:
        super().execute()
        cmd = ["clang-format", "-style=Microsoft", "--dump-config"]
        output = subprocess.run(cmd, capture_output=True, text=True)
        with open(os.path.join(self.project_dir, ".clang-format"), "wt") as file:
            file.write(output.stdout)

    def main_c_content(self) -> str:
        return """
#include "common.h"
#include <stdio.h>

int main()
{
    printf("hello world\\n");
    return RESULT_OK;
}
    """.lstrip()

    def common_h_content(self) -> str:
        return """
#pragma once

typedef enum {
    RESULT_OK = 0,
    RESULT_ERR = 1,
} result_e;

#define passert(condition)                                                      \\
    if (!(condition))                                                           \\
    {                                                                           \\
        fprintf(stderr, "%s:%d assertion failed\\n", __FILE_NAME__, __LINE__);   \\
        exit(EXIT_FAILURE);                                                     \\
    }
		""".lstrip()

    def makefile_content(self) -> str:
        return f"""
NAME={self.project_name}
CC=cc
STD=c23
CFLAGS=-Wall -Wextra -pedantic -Werror -O3
INC=-I./include
LDDFLAGS=-lm

SRC=./src/main.c
TARGET=./bin/${{NAME}}

main:
	${{CC}} ${{SRC}} -std=${{STD}} ${{INC}} ${{CFLAGS}} ${{LDDFLAGS}} -o ${{TARGET}}

run: main
	@${{TARGET}}
""".lstrip()


class JavaTemplateMaven(BaseTemplate):
    """
    template class for java+maven projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join(
            "src", "main", "java", "com", self.project_name, "Main.java"
        )
        test_path = os.path.join(
            "src", "test", "java", "com", self.project_name, "MainTest.java"
        )
        self.files_and_content = {
            "README.md": self.readme_md_content(),
            main_path: self.main_content(),
            test_path: self.test_content(),
            "pom.xml": self.pom_xml_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["java-maven"]

    def gitignore_entries(self) -> list[str]:
        return [".classpath", "target", ".project", ".settings", ".idea"]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("src", "main", "resources"),
            os.path.join("src", "main", "java", "com", self.project_name),
            os.path.join("src", "test", "java", "com", self.project_name),
        ]

    def execute(self) -> None:
        super().execute()
        print("Performing first compile...")
        cmd = ["mvn", "compile"]
        subprocess.run(cmd, cwd=self.project_dir)

    def main_content(self) -> str:
        return f"""
package com.{self.project_name};

public class Main {{
    public static void main(String[] args) {{
        System.out.println("hello world");
    }}
}}           
        """.strip()

    def test_content(self) -> str:
        return f"""
package com.{self.project_name};

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class MainTest {{
  @Test
  public void testAssertion() {{
    assertEquals(1, 1);
  }}
}}        
        """.strip()

    def pom_xml_content(self) -> str:
        return f"""
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.{self.project_name}</groupId>
  <artifactId>{self.project_name}</artifactId>
  <version>1.0</version>

  <properties>
    <java.version>21</java.version>
    <exec.mainClass>com.{self.project_name}.Main</exec.mainClass>
    <maven.compiler.source>${{java.version}}</maven.compiler.source>
    <maven.compiler.target>${{java.version}}</maven.compiler.target>
    <maven.compiler.release>${{java.version}}</maven.compiler.release>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>    
  </properties>

  <build>
    <plugins>
      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
          <archive>
            <manifest>
              <mainClass>com.{self.project_name}.Main</mainClass>
            </manifest>
          </archive>
        </configuration>
        <executions>
          <execution>
            <id>make-assembly</id>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

  <dependencies>
    <dependency>
        <groupId>org.junit.jupiter</groupId>
        <artifactId>junit-jupiter</artifactId>
        <version>5.10.3</version>
        <scope>test</scope>
    </dependency>
  </dependencies>
</project>
        """.strip()

    def readme_md_content(self) -> str:
        return f"""
## {self.project_name}

### Commands

```bash
# install dependencies.
$ mvn install

# first run.
# mvn compile exec:java

# run project.
$ mvn exec:java

# compile.
$ mvn clean compile package

# run jar.
$ java -jar ./target/{self.project_name}-1.0-jar-with-dependencies.jar
```
        """.strip()


class JavaTemplateGradle(BaseTemplate):
    """
    template class for java+gradle projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join(
            "src", "main", "java", "com", self.project_name, "Main.java"
        )
        test_path = os.path.join(
            "src", "test", "java", "com", self.project_name, "MainTest.java"
        )
        self.files_and_content = {
            "README.md": self.readme_md_content(),
            main_path: self.main_content(),
            test_path: self.test_content(),
            "build.gradle": self.build_gradle_content(),
            "gradle.properties": self.gradle_properties_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["java-gradle"]

    def gitignore_entries(self) -> list[str]:
        return [".classpath", "target", ".project", ".settings", ".idea", ".gradle", "build", "bin"]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("src", "main", "resources"),
            os.path.join("src", "main", "java", "com", self.project_name),
            os.path.join("src", "test", "java", "com", self.project_name),
        ]

    def main_content(self) -> str:
        return f"""
package com.{self.project_name};

public class Main {{
    public static void main(String[] args) {{
        System.out.println("hello world");
    }}
}}
        """.strip()

    def test_content(self) -> str:
        return f"""
package com.{self.project_name};

import static org.junit.jupiter.api.Assertions.*;
import org.junit.jupiter.api.Test;

public class MainTest {{
  @Test
  public void testAssertion() {{
    assertEquals(1, 1);
  }}
}}
        """.strip()

    def build_gradle_content(self) -> str:
        return f"""
plugins {{
    id 'java'
    id 'application'
}}

application {{
    mainClass = 'com.{self.project_name}.Main'
}}

repositories {{
    mavenCentral()
}}

jar {{
    archiveVersion =  '0.0.1'
    archiveBaseName = 'com.{self.project_name}'
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE
    exclude 'META-INF/LICENSE'
    exclude 'META-INF/NOTICE'

    manifest {{
        attributes['Main-Class'] = 'com.{self.project_name}.Main'
    }}

    from {{
        configurations.runtimeClasspath.collect {{ it.isDirectory() ? it : zipTree(it) }}
    }}
}}

testing {{
    suites {{
        test {{
            useJUnitJupiter('5.9.3')
        }}
    }}
}}

dependencies {{
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.9.3'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.9.3'
}}
        """.strip()

    def readme_md_content(self) -> str:
        return f"""
## {self.project_name}

### Commands

```bash
# run in development mode.
$ gradle run

# build for production.
$ gradle build

# run jar.
$ java -jar ./build/libs/{self.project_name}-0.0.1.jar
```
        """.strip()

    def gradle_properties_content(self) -> str:
        return """
org.gradle.configuration-cache=true
        """.strip()


class ScalaTemplate(BaseTemplate):
    """
    template class for scala+maven projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join(
            "src", "main", "scala", "com", self.project_name, "Main.scala"
        )
        self.files_and_content = {
            "README.md": self.readme_md_content(),
            main_path: self.main_content(),
            "pom.xml": self.pom_xml_content(),
            ".scalafmt.conf": self.scalafmt_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["scala"]

    def gitignore_entries(self) -> list[str]:
        return [
            ".classpath",
            "target",
            ".project",
            ".settings",
            ".idea",
            ".metals",
            ".vscode",
            ".bsp",
            ".scala-build",
            ".bloop",
        ]

    def project_directories(self) -> list[str]:
        return [
            os.path.join("src", "main", "scala", "com", self.project_name),
        ]

    def execute(self) -> None:
        super().execute()
        # setup bloop.
        print("Running bloopInstall")
        cmd = ["mvn", "ch.epfl.scala:bloop-maven-plugin:bloopInstall"]
        subprocess.run(cmd, cwd=self.project_dir)

    def main_content(self) -> str:
        return f"""
package com.{self.project_name}

object Main {{
    def main(args: Array[String]): Unit = {{
        println("Hello, world!")
    }}
}}
        """.strip()

    def pom_xml_content(self) -> str:
        return f"""
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>

  <groupId>com.{self.project_name}</groupId>
  <artifactId>{self.project_name}</artifactId>
  <version>1.0</version>

  <build>
    <plugins>
      <plugin>
        <groupId>net.alchim31.maven</groupId>
        <artifactId>scala-maven-plugin</artifactId>
        <version>4.9.6</version>
        <executions>
          <execution>
            <goals>
              <goal>compile</goal>
              <goal>testCompile</goal>
            </goals>
          </execution>
        </executions>
        <configuration>
          <scalaVersion>${{scala.version}}</scalaVersion>
          <mainClass>${{exec.mainClass}}</mainClass>
        </configuration>
      </plugin>

      <plugin>
        <artifactId>maven-assembly-plugin</artifactId>
        <configuration>
          <descriptorRefs>
            <descriptorRef>jar-with-dependencies</descriptorRef>
          </descriptorRefs>
          <archive>
            <manifest>
              <mainClass>${{exec.mainClass}}</mainClass>
            </manifest>
          </archive>
        </configuration>
        <executions>
          <execution>
            <phase>package</phase>
            <goals>
              <goal>single</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

  <properties>
    <java.version>21</java.version>
    <scala.version>3.7.3</scala.version>
    <exec.mainClass>com.{self.project_name}.Main</exec.mainClass>
    <maven.compiler.source>${{java.version}}</maven.compiler.source>
    <maven.compiler.target>${{java.version}}</maven.compiler.target>
    <maven.compiler.release>${{java.version}}</maven.compiler.release>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <project.reporting.outputEncoding>UTF-8</project.reporting.outputEncoding>
  </properties>

  <dependencies>
    <dependency>
      <groupId>org.scala-lang</groupId>
      <artifactId>scala3-library_3</artifactId>
      <version>${{scala.version}}</version>
    </dependency>
  </dependencies>
</project>
        """.strip()

    def readme_md_content(self) -> str:
        return f"""
## {self.project_name}

## scala

### Commands

```bash
# install dependencies.
$ mvn install

# run project.
$ mvn scala:run

# compile.
$ mvn clean package

# run jar.
$ java -jar ./target/{self.project_name}-1.0-jar-with-dependencies.jar
```
        """.strip()

    def scalafmt_content(self) -> str:
        return """
version = "3.7.15"
runner.dialect = scala3
align.preset = more
maxColumn = 100
indent.main = 4
indent.significant = 4
indent.callSite = 4
indent.callSite = 4
indent.ctrlSite = 4
indent.defnSite = 4
indent.ctorSite = 4
indent.matchSite = 4
indent.caseSite = 4
indent.extendSite = 4
indent.withSiteRelativeToExtends = 4
		""".strip()


class TsTemplate(BaseTemplate):
    """
    template class for Javascript projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        main_path = os.path.join("src", "main.ts")
        main_test_path = os.path.join("src", "main.test.ts")

        self.files_and_content = {
            "README.md": self.readme_content(),
            main_path: self.main_content(),
            main_test_path: self.main_test_content(),
            "tsconfig.json": self.tsconfig_content(),
            "package.json": self.package_json_content(),
            "eslint.config.js": self.eslint_config_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["ts", "typescript"]

    def gitignore_entries(self) -> list[str]:
        return ["node_modules/", ".DS_Store", "dist/"]

    def project_directories(self) -> list[str]:
        return ["src"]

    def execute(self) -> None:
        super().execute()

        # install npm dependencies.
        print("installing dependencies...")
        cmd = ["npm", "i"]
        subprocess.run(cmd, cwd=self.project_dir)

    def readme_content(self) -> str:
        return f"""
# {self.project_name}

## Scripts

```bash
# start the application
$ npm start

# run the tests (using native NodeJS test runner)
$ npm test

# perform linting (using Eslint) and type checking (using TSC)
$ npm run check

# format code (using prettier)
$ npm run fmt
```
		""".strip()

    def main_content(self) -> str:
        return """
function main(): void {
    console.log("Hello world")
}

main()
		""".strip()

    def main_test_content(self) -> str:
        return """
import test from "node:test"
import assert from "node:assert/strict"

test("simple test", async () => {
    assert.equal(true, true)
})
		""".strip()

    def tsconfig_content(self) -> str:
        return """
{
    "$schema": "https://json.schemastore.org/tsconfig",
    "display": "Strictest",
    "compilerOptions": {
        "strict": true,
        "allowUnusedLabels": false,
        "allowUnreachableCode": false,
        "allowImportingTsExtensions": true,
        "moduleResolution": "bundler",
        "noEmit": true,
        "exactOptionalPropertyTypes": true,
        "noFallthroughCasesInSwitch": true,
        "noImplicitOverride": true,
        "noImplicitReturns": true,
        "noPropertyAccessFromIndexSignature": true,
        "noUncheckedIndexedAccess": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "isolatedModules": true,
        "checkJs": true,
        "esModuleInterop": true,
        "target": "ESNext",
        "module": "preserve",
        "verbatimModuleSyntax": true,
        "skipLibCheck": true,
        "types": [
            "node"
        ],
        "outDir": "./dist",
        "baseUrl": ".",
        "paths": {
            "#src/*": [
                "./src/*"
            ]
        }
    },
    "exclude": [
        "node_modules",
        "dist"
    ]
}
		""".strip()

    def package_json_content(self) -> str:
        return """
{
    "name": "sandbox",
    "version": "0.0.1",
    "type": "module",
    "scripts": {
        "start": "node ./src/main.ts",
        "fmt": "npx prettier --write ./src/",
        "type-check": "npx tsc --noEmit",
        "lint": "npx eslint --fix ./src/",
        "check": "npm run type-check && npm run lint",
        "build": "npx esbuild src/main.ts --bundle --outfile=dist/index.js --platform=node --format=esm --packages=external --minify",
        "test": "node --test"
    },
    "prettier": {
        "singleQuote": false,
        "semi": false,
        "tabWidth": 4,
        "trailingComma": "all",
        "printWidth": 100
    },
    "imports": {
        "#src/*": "./src/*"
    },
    "devDependencies": {
        "@types/node": "^24.2.0",
        "esbuild": "^0.27.0",
        "eslint": "^9.32.0",
        "prettier": "^3.6.2",
        "typescript": "^5.9.2",
        "typescript-eslint": "^8.47.0"
    }
}
	""".strip()

    def eslint_config_content(self) -> str:
        return """
import tseslint from "typescript-eslint"

export default [
    { files: ["**/*.ts"] },
    ...tseslint.configs.recommended,
    {
        rules: {
            "no-console": "warn",
            "no-warning-comments": [
                "warn",
                { terms: ["TODO", "FIXME"], location: "anywhere" },
            ],
            quotes: [
                "warn",
                "double",
                {
                    allowTemplateLiterals: true,
                    avoidEscape: true,
                },
            ],
            semi: ["warn", "never"],
            "no-unused-vars": "warn",
        },
    },
]
	""".strip()


class PythonTemplate(BaseTemplate):
    """
    template class for Python projects.
    """

    def __init__(self, project_name: str) -> None:
        super().__init__(project_name)

        app_path = os.path.join("app", "app.py")
        app_test_path = os.path.join("app", "app_test.py")
        init_app_path = os.path.join("app", "__init__.py")

        self.files_and_content = {
            "README.md": self.readme_content(),
            app_path: self.app_content(),
            app_test_path: self.app_test_content(),
            init_app_path: self.init_app_content(),
            "main.py": self.main_content(),
            "pyproject.toml": self.pyproject_toml_content(),
        }

    @staticmethod
    def template_names() -> list[str]:
        return ["py", "python"]

    def gitignore_entries(self) -> list[str]:
        return [
            "__pycache__",
            "build",
            ".mypy_cache",
            "*.egg-info",
            ".DS_Store",
            ".vscode",
            ".venv",
        ]

    def project_directories(self) -> list[str]:
        return ["app"]

    def readme_content(self) -> str:
        return f"""
# {self.project_name}

## Commands

```bash
# install run-time dependencies.
$ pip install .

# install dev dependencies.
$ pip install .[dev]

# run project.
$ python -m main
```
""".strip()

    def init_app_content(self) -> str:
        return """
from .app import main
      """.strip()

    def app_content(self) -> str:
        return """
def main() -> None:
    print("hello world")
        """.strip()

    def app_test_content(self) -> str:
        return """
from unittest import TestCase


class TestMain(TestCase):
    def test_main(self) -> None:
        self.assertTrue(True)
      """.strip()

    def main_content(self) -> str:
        return """
from app import main


if __name__ == "__main__":
    try:
        main()
    except Exception as ex:
        print("error: ", ex)
        """.strip()

    def pyproject_toml_content(self) -> str:
        return f"""
[project]
name = "{self.project_name}"
version = "1.0.0"
dependencies = []

[project.optional-dependencies]
dev = []
        """.strip()


def main() -> None:
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", "--name", help="Project name", required=True)
    parser.add_argument("-t", "--template", help="Project template", required=True)
    args = parser.parse_args()

    registered_templates: list[BaseTemplate] = [
        GoTemplate(args.name),
        CTemplate(args.name),
        JavaTemplateMaven(args.name),
        JavaTemplateGradle(args.name),
        ScalaTemplate(args.name),
        TsTemplate(args.name),
        PythonTemplate(args.name),
    ]

    found = False
    for template in registered_templates:
        if args.template in template.template_names():
            found = True
            template.execute()
            break

    if not found:
        raise Exception(f"invalid template name: {args.template}")


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("ctrl+c: exiting...")
    except Exception as e:
        print("error:", e)
